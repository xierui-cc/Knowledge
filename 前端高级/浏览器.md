★cookie和session放哪里，cookie能做的事情和存在的价值

    因为http是无状态的，而网站肯定是需要有状态的（会话），cookie和session都是实现会话而生的，只不过具体实施一个是客户端一个是服务端。
    cookie 还跟请求头有关系(导致跨域攻击)

★token(令牌)

    Token 是在服务端产生的。服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位，
    一般用无状态Token，服务器只要验证这个token确实是有效的就好了。

★分享转发带token

    一般是url带过去，不用url跨平台的话有点麻烦，首先的解决跨域，再去拿token，目前没看到啥优雅的解决方案

★base64为什么能提升性能，优缺点。

    一般体积小，变化少的图片适合用base64, 后续下载就不用新的http了。
    优点: 可以将二进制数据转化为可打印字符，方便传输数据。
    缺点：内容编码后体积变大，编码和解码需要额外工作量。 css解析开销大，而且有兼容性问题

★介绍webp这个图片文件格式

    体积小，肉眼不可见的失真。不兼容的地方要额外的解码器。

★介绍下表单提交，和formData有什么关系

    formdata是h5的新对象，可以追加参数。

★formData和原生的ajax有什么区别

    ajax要设置请求可以传各种数据，而formdata有默认application/x-www-form-urlencoded只能传formdata

★localStorage和cookie有什么区别

    cookie会丢到请求头里面去(本来就是应对http无状态而生的)，而localStorage只是一个前端存数据的地方(前端数据仓库)。
    localStorage容量多，更便捷（很方便的api给你用）

★WebWorker
★Service Worker

---------------------------------------------------------------------------------------------------------------推送技术

★短连接轮询与长链接轮询

    短链接搞完会关掉tcp,消耗太大。
    长链接没有返回值的时候阻塞，有返回值的时候也会关掉tcp再连接。
    (在http1.1中虽然客户端可以在长连接没有返回的时候再发别的请求，但是服务端还是会根据顺序响应，所以这等于直接占用了一个tcp连接,而且对于服务端来说长连接也是压力)

★iframe流

    类似于jsonp，可以跨域，iframe有一些优点，但是我感觉跟长连接轮询差不多啊？

★SSE与WebSocket

    WebSocket是全双工通道，可以双向通信，功能更强；
    WebSocket是一个新的协议，需要服务器端支持，较重的协议，相对复杂；

    SSE是单向通道，只能服务器向浏览器端发送。
    SSE则是部署在 HTTP协议之上的，现有的服务器软件都支持，轻量级协议，相对简单。
    SSE默认支持断线重连。
    SSE支持自定义发送的数据类型。
    SSE不支持CORS 参数url就是服务器网址，必须与当前网页的网址在同一个网域（domain），而且协议和端口都必须相同。

---------------------------------------------------------------------------------------------------------------事件流
★浏览器事件流向

    冒泡 DOM树的叶子到根
    捕获 DOM树的根到叶子
    ---先捕获后冒泡

★介绍事件代理以及优缺点

    事件源targt可以模拟找到真实点击
    优点：
    减少事件注册，节省内存。
    简化了dom节点更新时，相应事件的更新。

    缺点：
    事件委托基于冒泡，对于不冒泡的事件不支持。
    需要就近委托-免得出现复杂情况（就是中间别隔太多层了）

----------------------------------------------------------------------------------------------------------------跨域

★介绍同源策略

    协议、主机、端口一致即同源
    所谓同源策略就是浏览器不允许运行其他域的js(就是只针对JS，因为JS可以用来干坏事，所以有些标签却可以加载其他域的资源)

★表单可以跨域吗

    可以，而from表单提交后是不会有任何数据返回的，符合简单跨域，浏览器认为是安全的。

★跨域

    jsonp
        利用script标签src属性,静态资源请求只支持get方法,传回来的数据就是脚本而已

    CORS
        简单请求
            简单请求就是ajax为了兼容表单提交，浏览器会发送数据，但是不会响应结果（服务端可以处理数据）。
        复杂请求
            服务端消息头配置Access-Control-Allow-Origin，表示接受匹配的域发跨域请求。
            浏览器会在正式请求之前发送一次预检请求（option请求），就是说，正式请求之前，浏览器会去问服务端我这个地址能不能访问你，如果可以，浏览器才会发送正式的请求，否则报错。
            (预检请求通过后会返回给你一个预检请求的缓存，在缓存时间以内相当于简单请求。)

    反向代理
        代理成一个域，浏览器就不会触发同源策略了

    postMessage
        先用postMessage将数据传给iframe，iframe监听拿到后，发请求(iframe本来就可以跨域)

    document.domain
        除了顶级域名外，有其他相同的上级域名就可以设置

    window.name
        window.name这个属性不会被页面重载刷新，你设置怎么样的，一直到页面关闭，都不会变。
        利用这一点，先用iframe调用别的域名下面的连接，返回脚本设置window.name，再把iframe设置成同源的，就可以拿到window对象了
        
    location.hash
        也是利用iframe，假设A->B->C,A,C同域，B跨域。
        B的iframe请求跨域数据后修改，C的hash，因为C和A是同域的就可以直接修改A的hash。
        （前端路由肯定不能这么搞，差不多就是组件代理的思想，hash只是数据载体）
