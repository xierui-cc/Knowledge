★get和post有什么区别

    最早get是用来请求资源的，会被浏览器缓存。

★网络的五层模型 tcp属于哪一层

    1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)

★介绍DNS解析

    第一步：客户机提出域名解析请求,并将该请求发送给本地的域名服务器.
    第二步：当本地的域名服务器收到请求后,就先查询本地的缓存,如果有该纪录项,则本地的域名服务器就直接把查询的结果返回.
    第三步：如果本地的缓存中没有该纪录,则本地域名服务器就直接把请求发给根域名服务器,然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域)的主域名服务器的地址.
    第四步：本地服务器再向上一步返回的域名服务器发送请求,然后接受请求的服务器查询自己的缓存,如果没有该纪录,则返回相关的下级的域名服务器的地址.
    第五步：重复第四步,直到找到正确的纪录.
    第六步：本地域名服务器把返回的结果保存到缓存,以备下一次使用,同时还将结果返回给客户机.

★tcp3次握手

    如果只有两次的话 会导致 重复连接的问题 (防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误)
★tcp4次挥手

    避免另外一端还有没有发送完的数据

★http1.0与http1.1并发

    并发请求同一个域名资源数上限（谷歌同域名6个）所以有多域名加载

★http1.1时如何复用tcp连接

    在HTTP 1.0中，客户端的每一个HTTP请求都必须通过独立的TCP连接进行处理。
    在HTTP 1.1中，对这种方式进行了改进。客户端可以在一个TCP连接中发送多个HTTP请求，这种技术叫做HTTP复用（HTTP Multiplexing）。
    (TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上, 负载均衡)

★介绍http/2新特性

    二进制传输
        HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码,用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。HTP/2数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"。
    Header压缩
        "HPACK”算法,客户端和服务器两端建立“字典”，用索引号表示重复的字符串。(就是http1.x中，每次请求头都会包含大量的重复数据，太浪费)
    多路复用
        同域名下所有通信都在单个连接上完成。(一个域名一个TCP)
        单个连接可以承载任意数量的双向数据流。数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。(客户端可以交错的请求，服务段可以交错响应)(HTTP/2头部有优先级)
    Server Push(服务器推送)
        因为同一个域名TCP一直连接在，TCP本来就是双向的，以前没好好用而已,但是要注意缓存问题

★常见Http请求头 Http报文的请求会有几个部分

★介绍下HTTP状态码 403、301、302是什么

    400: 无效请求，不被服务器理解
    403: 禁止访问
    301 redirect: 301 代表永久性转移(Permanently Moved)
    302 redirect: 302 代表暂时性转移(Temporarily Moved )

★http缓存控制 缓存相关的HTTP请求头 304是什么

    强缓存
        (http1.0)Expires: Thu, 10 Nov 2017 08:45:11 GMT (时间，缺点是精度不够)
        (http1.1)Cache-control: max-age=2592000
        浏览器访问缓存，发现没过期直接拿数据，不会经过服务端，返回200（）

    协商缓存
        Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT（服务端给的最后一次修改时间）
        If-Modified-Since（客户端拿Last-Modified与服务端的Last-Modified对比，发现资源没有更新则返回304）

        Etag （解决上面 时间精度问题 一般是hash）
        If-None-Match

★HTTP和HTTPS的区别 HTTPS的加密过程（SSL/TLS）